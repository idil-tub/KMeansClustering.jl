<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · KMeansClustering.jl</title><meta name="title" content="Home · KMeansClustering.jl"/><meta property="og:title" content="Home · KMeansClustering.jl"/><meta property="twitter:title" content="Home · KMeansClustering.jl"/><meta name="description" content="Documentation for KMeansClustering.jl."/><meta property="og:description" content="Documentation for KMeansClustering.jl."/><meta property="twitter:description" content="Documentation for KMeansClustering.jl."/><meta property="og:url" content="https://idil-tub.github.io/KMeansClustering.jl/"/><meta property="twitter:url" content="https://idil-tub.github.io/KMeansClustering.jl/"/><link rel="canonical" href="https://idil-tub.github.io/KMeansClustering.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>KMeansClustering.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="getting_started/">Getting Started</a></li><li><a class="tocitem" href="installation/">Installation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/idil-tub/KMeansClustering.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/idil-tub/KMeansClustering.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="KMeansClustering"><a class="docs-heading-anchor" href="#KMeansClustering">KMeansClustering</a><a id="KMeansClustering-1"></a><a class="docs-heading-anchor-permalink" href="#KMeansClustering" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/idil-tub/KMeansClustering.jl">KMeansClustering</a>.</p><ul><li><a href="#KMeansClustering.Centroid.CentroidCalculator-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Centroid.CentroidCalculator</code></a></li><li><a href="#KMeansClustering.Centroid.CentroidCalculator"><code>KMeansClustering.Centroid.CentroidCalculator</code></a></li><li><a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>KMeansClustering.Centroid.EuclideanMeanCentroid</code></a></li><li><a href="#KMeansClustering.Centroid.EuclideanMeanCentroid-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Centroid.EuclideanMeanCentroid</code></a></li><li><a href="#KMeansClustering.Init.ClusterInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.ClusterInit</code></a></li><li><a href="#KMeansClustering.Init.ClusterInit"><code>KMeansClustering.Init.ClusterInit</code></a></li><li><a href="#KMeansClustering.Init.KMeansPPInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.KMeansPPInit</code></a></li><li><a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansClustering.Init.KMeansPPInit</code></a></li><li><a href="#KMeansClustering.Init.UniformRandomInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.UniformRandomInit</code></a></li><li><a href="#KMeansClustering.Init.UniformRandomInit"><code>KMeansClustering.Init.UniformRandomInit</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.BkMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.BkMeans</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>KMeansClustering.KMeansAlgorithms.BkMeans</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.KMeansAlgorithm</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansClustering.KMeansAlgorithms.KMeansAlgorithm</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>KMeansClustering.KMeansAlgorithms.Lloyd</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.Lloyd-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.Lloyd</code></a></li><li><a href="#KMeansClustering.Norm.EuclideanNormSqr"><code>KMeansClustering.Norm.EuclideanNormSqr</code></a></li><li><a href="#KMeansClustering.Norm.EuclideanNormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Norm.EuclideanNormSqr</code></a></li><li><a href="#KMeansClustering.Norm.NormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Norm.NormSqr</code></a></li><li><a href="#KMeansClustering.Norm.NormSqr"><code>KMeansClustering.Norm.NormSqr</code></a></li><li><a href="#KMeansClustering.KMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeans</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.buildClusters-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.buildClusters</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KMeans(x::AbstractVector{V}, k::Int64; init::ClusterInit{V}=UniformRandomInit{V}(), max_iter::Int64=300, tol::Float64=0.0001, algorithm::KMeansAlgorithm=Lloyd{V}(), centroid::CentroidCalculator{V}=EuclideanMeanCentroid{V}(), normSqr::NormSqr{V}=EuclideanNormSqr{V}())::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Perform K-means clustering on the data <code>x</code> with <code>k</code> clusters.</p><p>This function provides a flexible interface to various K-means clustering implementations, allowing customization of initialization, algorithm, centroid calculation, and distance metric.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{V}</code>: Input data as an abstract vector of type <code>V</code>.</li><li><code>k::Int64</code>: Number of clusters to form.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>init::ClusterInit{V}=UniformRandomInit{V}()</code>: Cluster initialization method.</li><li><code>max_iter::Int64=300</code>: Maximum number of iterations.</li><li><code>tol::Float64=0.0001</code>: Tolerance for convergence.</li><li><code>algorithm::KMeansAlgorithm=Lloyd{V}()</code>: K-means algorithm variant to use.</li><li><code>centroid::CentroidCalculator{V}=EuclideanMeanCentroid{V}()</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}=EuclideanNormSqr{V}()</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic usage with default parameters
data = [rand(3) for _ in 1:100]  # 100 3D points
result = KMeans(data, 5)

# Custom configuration
result = KMeans(data, 5,
    init=KMeansPPInit{Vector{Float64}}(),
    max_iter=500,
    tol=1e-6,
    algorithm=BkMeans{Vector{Float64}}(10, 0.001),
    centroid=EuclideanMeanCentroid{Vector{Float64}}(),
    normSqr=EuclideanNormSqr{Vector{Float64}}()
)</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a>, <a href="#KMeansClustering.Norm.NormSqr"><code>NormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/KMeansClustering.jl#L16-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.ClusterInit" href="#KMeansClustering.Init.ClusterInit"><code>KMeansClustering.Init.ClusterInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusterInit{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing cluster initialization strategies for clustering algorithms.</p><p>This type is parameterized by <code>V</code>, which can be either a non-integer numeric type or  an array of non-integer numeric types.</p><p><strong>Purpose</strong></p><p>Subtypes of <code>ClusterInit</code> are expected to implement specific initialization strategies  for clustering algorithms, such as k-means++ initialization, random initialization,  or other custom methods.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A concrete subtype might be implemented as:
struct MyRandomInit{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: ClusterInit{V} end</code></pre><p>See also <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/init.jl#L9-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.ClusterInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Init.ClusterInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.ClusterInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::ClusterInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Initialize <code>k</code> cluster centers from <code>samples</code> using the strategy defined by <code>c</code> and the norm <code>normSqr</code>.</p><p>This is an abstract method that should be implemented by concrete subtypes of <code>ClusterInit</code>. If called on the abstract type, it raises an error.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples.</li><li><code>k::Int64</code>: Number of cluster centers to initialize.</li><li><code>normSqr::NormSqr{V}</code>: Norm function to be used in the initialization process.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{V}</code>: A vector of <code>k</code> initialized cluster centers.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>ClusterInit</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Implementing for a concrete subtype:
function (c::MyCustomInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}
    # Custom initialization logic here
    return initialize_centers(samples, k, normSqr)
end</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a> end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/init.jl#L32-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.KMeansPPInit" href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansClustering.Init.KMeansPPInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KMeansPPInit{V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}} &lt;: ClusterInit{V}</code></pre><p>A concrete implementation of <code>ClusterInit</code> representing the k-means++ initialization strategy for clustering algorithms.</p><p>This struct implements the k-means++ initialization method, which selects initial cluster centers with a probability proportional to their squared distance from the closest center already chosen.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
kmeans_pp_init = KMeansPPInit{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/init.jl#L151-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.KMeansPPInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Init.KMeansPPInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.KMeansPPInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::KMeansPPInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Perform K-means++ initialization to select initial cluster centers.</p><p>This method implements the call operator for <code>KMeansPPInit</code>, allowing instances to be used as functions to generate initial cluster centers using the K-means++ algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples.</li><li><code>k::Int64</code>: Number of cluster centers to initialize.</li><li><code>normSqr::NormSqr{V}</code>: Norm function used to calculate distances between points.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{V}</code>: A vector of <code>k</code> initialized cluster centers.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">kmeans_pp = KMeansPPInit{Vector{Float64}}()
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
centers = kmeans_pp(samples, k, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/init.jl#L172-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.UniformRandomInit" href="#KMeansClustering.Init.UniformRandomInit"><code>KMeansClustering.Init.UniformRandomInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformRandomInit{V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}} &lt;: ClusterInit{V}</code></pre><p>A concrete implementation of <code>ClusterInit</code> representing uniform random initialization for clustering algorithms.</p><p>This struct implements the uniform random initialization strategy, where initial cluster centers are chosen uniformly at random from the bounding hyperrectangle of the input samples.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
uniform_init = UniformRandomInit{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/init.jl#L71-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.UniformRandomInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Init.UniformRandomInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.UniformRandomInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::UniformRandomInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Initialize <code>k</code> cluster centers from <code>samples</code> using uniform random distribution over the bounding hyperrectangle of the samples.</p><p>This method implements the call operator for <code>UniformRandomInit</code>, allowing instances to be used as functions to generate initial cluster centers.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples.</li><li><code>k::Int64</code>: Number of cluster centers to initialize.</li><li><code>normSqr::NormSqr{V}</code>: Norm function (not used in this implementation but required for interface consistency).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{V}</code>: A vector of <code>k</code> initialized cluster centers.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">uniform_init = UniformRandomInit{Vector{Float64}}()
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
centers = uniform_init(samples, k, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/init.jl#L92-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.BkMeans" href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>KMeansClustering.KMeansAlgorithms.BkMeans</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BkMeans{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: KMeansAlgorithm{V}</code></pre><p>A concrete implementation of <code>KMeansAlgorithm</code> representing the BkMeans clustering algorithm.</p><p><a href="https://arxiv.org/abs/2006.15666">BkMeans</a> is a variant of the K-means algorithm that aims to improve clustering quality by iteratively refining the solution through a process of &quot;breathing&quot; (adding and removing centers).</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Fields</strong></p><ul><li><code>m::Int64</code>: The number of centers to add and remove in each iteration. Default is 5.</li><li><code>eps::Float64</code>: A small value used in the center perturbation step. Default is 0.001.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">BkMeans{V}(m::Int64 = 5, eps::Float64 = 0.001) where V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code></pre><p>Constructs a BkMeans instance with the specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int64</code>: The number of centers to add and remove in each iteration. Must be non-negative.</li><li><code>eps::Float64</code>: A small value used in the center perturbation step. Must be non-negative.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either <code>m</code> or <code>eps</code> is negative.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data with default parameters
bkmeans = BkMeans{Vector{Float64}}()

# Create an instance with custom parameters
bkmeans_custom = BkMeans{Vector{Float64}}(10, 0.0005)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L194-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.BkMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.BkMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.BkMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(a::BkMeans{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Execute the BkMeans clustering algorithm on the given samples.</p><p>This method implements the call operator for <code>BkMeans</code>, allowing instances to be used as functions to perform K-means clustering using the BkMeans algorithm variant. BkMeans aims to improve clustering quality by iteratively refining the solution through a process of &quot;breathing&quot; (adding and removing centers).</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples to be clustered.</li><li><code>k::Int64</code>: Number of clusters to form.</li><li><code>init::ClusterInit{V}</code>: Initialization method for cluster centers.</li><li><code>max_iter::Int64</code>: Maximum number of iterations for the algorithm.</li><li><code>tol::Float64</code>: Convergence tolerance.</li><li><code>centroid::CentroidCalculator{V}</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">bkmeans = BkMeans{Vector{Float64}}(5, 0.001)
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
init = KMeansPPInit{Vector{Float64}}()
max_iter = 100
tol = 1e-4
centroid = EuclideanMeanCentroid{Vector{Float64}}()
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
results = bkmeans(samples, k, init, max_iter, tol, centroid, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L242-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.KMeansAlgorithm" href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansClustering.KMeansAlgorithms.KMeansAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KMeansAlgorithm{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing K-means clustering algorithms.</p><p>This type is parameterized by <code>V</code>, which can be either a non-integer numeric type or  an array of non-integer numeric types, representing the type of data points being clustered.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of the data points. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Purpose</strong></p><p>Subtypes of <code>KMeansAlgorithm</code> are expected to implement specific variants of the  K-means clustering algorithm, such as Lloyd&#39;s algorithm, mini-batch K-means, or  other custom methods.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A concrete subtype might be implemented as:
struct MyAlgorithm{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: KMeansAlgorithm{V} end</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.KMeansAlgorithm-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.KMeansAlgorithm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(a::KMeansAlgorithm{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Execute a K-means clustering algorithm on the given samples.</p><p>This is an abstract method that should be implemented by concrete subtypes of <code>KMeansAlgorithm</code>. If called on the abstract type, it raises an error.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples to be clustered.</li><li><code>k::Int64</code>: Number of clusters to form.</li><li><code>init::ClusterInit{V}</code>: Initialization method for cluster centers.</li><li><code>max_iter::Int64</code>: Maximum number of iterations for the algorithm.</li><li><code>tol::Float64</code>: Convergence tolerance.</li><li><code>centroid::CentroidCalculator{V}</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>KMeansAlgorithm</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Implementing for a concrete subtype:
function (a::MyCustomKMeans{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}
    # Custom K-means algorithm implementation
    return cluster_results
end</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L34-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.Lloyd" href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>KMeansClustering.KMeansAlgorithms.Lloyd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lloyd{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: KMeansAlgorithm{V}</code></pre><p>A concrete implementation of <code>KMeansAlgorithm</code> representing Lloyd&#39;s algorithm for K-means clustering.</p><p>Lloyd&#39;s algorithm, also known as the standard K-means algorithm, iteratively reassigns points  to the nearest cluster center and recalculates cluster centers until convergence or a maximum  number of iterations is reached.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
lloyd_kmeans = Lloyd{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L76-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.Lloyd-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.Lloyd-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.Lloyd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(a::Lloyd{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Execute Lloyd&#39;s K-means clustering algorithm on the given samples.</p><p>This method implements the call operator for <code>Lloyd</code>, allowing instances to be used as functions to perform K-means clustering using Lloyd&#39;s algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples to be clustered.</li><li><code>k::Int64</code>: Number of clusters to form.</li><li><code>init::ClusterInit{V}</code>: Initialization method for cluster centers.</li><li><code>max_iter::Int64</code>: Maximum number of iterations for the algorithm.</li><li><code>tol::Float64</code>: Convergence tolerance.</li><li><code>centroid::CentroidCalculator{V}</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>k ≤ 0</code> or if <code>k</code> is greater than the number of samples.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lloyd = Lloyd{Vector{Float64}}()
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
init = KMeansPPInit{Vector{Float64}}()
max_iter = 100
tol = 1e-4
centroid = EuclideanMeanCentroid{Vector{Float64}}()
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
results = lloyd(samples, k, init, max_iter, tol, centroid, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L98-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.buildClusters-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.buildClusters-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.buildClusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">buildClusters(xs::AbstractVector{V}, init::AbstractVector{V}, normSqr::NormSqr{V})::Vector{Vector{V}} where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Assigns each sample in <code>xs</code> to the nearest cluster center in <code>init</code>.</p><p>Returns a vector of clusters, where each cluster is a vector of samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/kmeans_algorithms.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.EuclideanNormSqr" href="#KMeansClustering.Norm.EuclideanNormSqr"><code>KMeansClustering.Norm.EuclideanNormSqr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanNormSqr{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: NormSqr{V}</code></pre><p>A concrete implementation of <code>NormSqr</code> representing the squared Euclidean norm.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input for which this norm is defined.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance
euclidean_norm_sqr = EuclideanNormSqr{Vector{Float64}}()</code></pre><p>See also: <a href="#KMeansClustering.Norm.NormSqr"><code>NormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/norm.jl#L54-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.EuclideanNormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Norm.EuclideanNormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Norm.EuclideanNormSqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::EuclideanNormSqr{V})(x::V)::T where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Compute the squared Euclidean norm of <code>x</code>.</p><p>This method implements the call operator for <code>EuclideanNormSqr</code>, allowing instances to be used as functions to calculate squared Euclidean norms.</p><p><strong>Returns</strong></p><ul><li><code>T</code>: The computed squared Euclidean norm, which is a non-integer numeric type.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements and the result.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input, either a scalar or an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">euclidean_norm_sqr = EuclideanNormSqr{Vector{Float64}}()
v = [3.0, 4.0]
result = euclidean_norm_sqr(v)  # Returns 25.0</code></pre><p>See also: <a href="#KMeansClustering.Norm.NormSqr"><code>NormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/norm.jl#L71-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.NormSqr" href="#KMeansClustering.Norm.NormSqr"><code>KMeansClustering.Norm.NormSqr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormSqr{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing squared norms.</p><p>The type parameter <code>V</code> can be either a non-integer numeric type or an array of non-integer numeric types. This allows for representation of squared norms of scalars, vectors, or matrices with non-integer elements.</p><p><strong>Examples</strong></p><p>```julia</p><p><strong>Concrete subtypes might be implemented as:</strong></p><p><strong>struct MyNormSqr{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: NormSqr{V}</strong></p><p><strong>myParameter::Any</strong></p><p><strong>end</strong></p><p>See also: <a href="#KMeansClustering.Norm.EuclideanNormSqr"><code>EuclideanNormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/norm.jl#L6-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.NormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Norm.NormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Norm.NormSqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::NormSqr{V})(x::V)::T where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Compute the squared norm of <code>x</code> using the norm represented by <code>c</code>.</p><p><strong>Returns</strong></p><ul><li><code>T</code>: The computed squared norm, which is a non-integer numeric type.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements and the result.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input, either a scalar or an array.</li></ul><p>This is an abstract method that should be implemented by concrete subtypes of <code>NormSqr</code>. If called on the abstract type, it raises an error.</p><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>NormSqr</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">function (c::MyNormSqr{V})(x::V)::T where V&lt;:AbstractVector{&lt;:NonInteger}
    return sum(abs, x)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/norm.jl#L24-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.CentroidCalculator" href="#KMeansClustering.Centroid.CentroidCalculator"><code>KMeansClustering.Centroid.CentroidCalculator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CentroidCalculator{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing methods for calculating centroids in clustering algorithms.</p><p>This type is parameterized by <code>V</code>, which can be either a non-integer numeric type or  an array of non-integer numeric types, representing the type of data points for which  centroids are being calculated.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of the data points. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Purpose</strong></p><p>Subtypes of <code>CentroidCalculator</code> can be used to implement different ways of calculating the centroid for k-Means.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A concrete subtype might be implemented as:
struct CustomCentroid{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: CentroidCalculator{V} end</code></pre><p>See also <a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>EuclideanMeanCentroid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/centroid.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.CentroidCalculator-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Centroid.CentroidCalculator-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Centroid.CentroidCalculator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::CentroidCalculator{V})(samples::AbstractVector{V}, normSqr::NormSqr{V})::V where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Calculate the center of a cluster from the given <code>samples</code> using the provided <code>normSqr</code>.</p><p>This is an abstract method that should be implemented by concrete subtypes of <code>CentroidCalculator</code>. If called on the abstract type, it raises an error.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: A vector of data points in the cluster.</li><li><code>normSqr::NormSqr{V}</code>: The squared norm function used for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The calculated center of the cluster.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and the returned center.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>CentroidCalculator</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">function (c::CustomCentroid{V})(samples::AbstractVector{V}, normSqr::NormSqr{V})::V where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}
    return samples[1]
end</code></pre><p>See also <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a>, <a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>EuclideanMeanCentroid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/centroid.jl#L31-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.EuclideanMeanCentroid" href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>KMeansClustering.Centroid.EuclideanMeanCentroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanMeanCentroid{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: CentroidCalculator{V}</code></pre><p>A concrete implementation of <code>CentroidCalculator</code> that calculates the centroid of a cluster  using the Euclidean mean (arithmetic average) of the sample points.</p><p>This centroid calculator is suitable for use with Euclidean distance-based clustering algorithms.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input samples and calculated centroids. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
euclidean_mean = EuclideanMeanCentroid{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/centroid.jl#L66-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.EuclideanMeanCentroid-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Centroid.EuclideanMeanCentroid-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Centroid.EuclideanMeanCentroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::EuclideanMeanCentroid{V})(samples::AbstractVector{V}, normSqr::NormSqr{V})::V where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Calculate the centroid of a cluster using the standard Euclidean mean (arithmetic average) of the sample points.</p><p>This method implements the call operator for <code>EuclideanMeanCentroid</code>, allowing instances to be used as functions to compute cluster centroids.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: A vector of data points in the cluster.</li><li><code>normSqr::NormSqr{V}</code>: The squared norm function (not used in this implementation but required for interface consistency).</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The calculated centroid of the cluster, which is the arithmetic mean of all points.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and the returned centroid.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">euclidean_mean = EuclideanMeanCentroid{Vector{Float64}}()
samples = [rand(3) for _ in 1:10]  # 10 3D points
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
centroid = euclidean_mean(samples, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a>, <a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>EuclideanMeanCentroid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/f6259f40815dcccb9ff61627049b4cb02c9a8611/src/centroid.jl#L87-L115">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="getting_started/">Getting Started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 9 July 2024 13:29">Tuesday 9 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
