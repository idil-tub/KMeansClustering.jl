<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · KMeansClustering.jl</title><meta name="title" content="Public API · KMeansClustering.jl"/><meta property="og:title" content="Public API · KMeansClustering.jl"/><meta property="twitter:title" content="Public API · KMeansClustering.jl"/><meta name="description" content="Documentation for KMeansClustering.jl."/><meta property="og:description" content="Documentation for KMeansClustering.jl."/><meta property="twitter:description" content="Documentation for KMeansClustering.jl."/><meta property="og:url" content="https://idil-tub.github.io/KMeansClustering.jl/reference/"/><meta property="twitter:url" content="https://idil-tub.github.io/KMeansClustering.jl/reference/"/><link rel="canonical" href="https://idil-tub.github.io/KMeansClustering.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KMeansClustering.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#KMeansClustering"><span>KMeansClustering</span></a></li><li><a class="tocitem" href="#Init"><span>Init</span></a></li><li><a class="tocitem" href="#Norm"><span>Norm</span></a></li><li><a class="tocitem" href="#Centroid"><span>Centroid</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/idil-tub/KMeansClustering.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/idil-tub/KMeansClustering.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>KMeansClustering.jl</code>&#39;s public interface.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Public-Documentation">Public Documentation</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#KMeansClustering">KMeansClustering</a></li><li><a href="#Init">Init</a></li><li><a href="#Norm">Norm</a></li><li><a href="#Centroid">Centroid</a></li><li><a href="#Algorithms">Algorithms</a></li></ul></li></ul><h2 id="KMeansClustering"><a class="docs-heading-anchor" href="#KMeansClustering">KMeansClustering</a><a id="KMeansClustering-1"></a><a class="docs-heading-anchor-permalink" href="#KMeansClustering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering" href="#KMeansClustering"><code>KMeansClustering</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">KMeansClustering</code></pre><p>This module is the main module of this library and provides a flexible and extensible implementation of K-means clustering, allowing for customization of various aspects of the clustering process, including initialization methods, centroid calculation, norm, and algorithm variants.</p><p><strong>Submodules</strong></p><ul><li><code>Init</code>: Provides cluster initialization methods</li><li><code>Norm</code>: Provides an extensive norm</li><li><code>Centroid</code>: Provides an extensible centroid calculator</li><li><code>KMeansAlgorithms</code>: Implements the Lloyd and breating k-Means algorithms and providing an interface to write your own</li></ul><p><strong>Exports</strong></p><ul><li>Functions: <code>KMeans</code> The main entry point to this library</li></ul><p><strong>Example Usage</strong></p><p>```julia using KMeansClustering</p><p><strong>Generate sample data</strong></p><p>data = [rand(3) for _ in 1:100]  # 100 3D points</p><p><strong>Perform K-means clustering with default parameters</strong></p><p>result = KMeans(data, 5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/KMeansClustering.jl#L1-L26">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KMeans(x::AbstractVector{V}, k::Int64; init::ClusterInit{V}=UniformRandomInit{V}(), max_iter::Int64=300, tol::Float64=0.0001, algorithm::KMeansAlgorithm=Lloyd{V}(), centroid::CentroidCalculator{V}=EuclideanMeanCentroid{V}(), normSqr::NormSqr{V}=EuclideanNormSqr{V}())::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Perform K-means clustering on the data <code>x</code> with <code>k</code> clusters.</p><p>This function provides a flexible interface to various K-means clustering implementations, allowing customization of initialization, algorithm, centroid calculation, and distance metric.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{V}</code>: Input data as an abstract vector of type <code>V</code>.</li><li><code>k::Int64</code>: Number of clusters to form.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>init::ClusterInit{V}=UniformRandomInit{V}()</code>: Cluster initialization method.</li><li><code>max_iter::Int64=300</code>: Maximum number of iterations.</li><li><code>tol::Float64=0.0001</code>: Tolerance for convergence.</li><li><code>algorithm::KMeansAlgorithm=Lloyd{V}()</code>: K-means algorithm variant to use.</li><li><code>centroid::CentroidCalculator{V}=EuclideanMeanCentroid{V}()</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}=EuclideanNormSqr{V}()</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic usage with default parameters
data = [rand(3) for _ in 1:100]  # 100 3D points
result = KMeans(data, 5)

# Custom configuration
result = KMeans(data, 5,
    init=KMeansPPInit{Vector{Float64}}(),
    max_iter=500,
    tol=1e-6,
    algorithm=BkMeans{Vector{Float64}}(10, 0.001),
    centroid=EuclideanMeanCentroid{Vector{Float64}}(),
    normSqr=EuclideanNormSqr{Vector{Float64}}()
)</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a>, <a href="#KMeansClustering.Norm.NormSqr"><code>NormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/KMeansClustering.jl#L42-L87">source</a></section></article><h2 id="Init"><a class="docs-heading-anchor" href="#Init">Init</a><a id="Init-1"></a><a class="docs-heading-anchor-permalink" href="#Init" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init" href="#KMeansClustering.Init"><code>KMeansClustering.Init</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">KMeansClustering.Init</code></pre><p>A module providing cluster initialization strategies for clustering algorithms.</p><p>This module defines abstract and concrete types for initializing cluster centers, which are crucial components of clustering algorithms such as K-means.</p><p><strong>Types</strong></p><ul><li><code>ClusterInit{V}</code>: Abstract type for cluster initialization strategies</li><li><code>UniformRandomInit{V}</code>: Uniform random initialization</li><li><code>KMeansPPInit{V}</code>: K-means++ initialization</li></ul><p><strong>Functions</strong></p><ul><li>Call operators for <code>UniformRandomInit</code> and <code>KMeansPPInit</code> to perform initialization</li></ul><p><strong>Exports</strong></p><ul><li><code>ClusterInit</code></li><li><code>UniformRandomInit</code></li><li><code>KMeansPPInit</code></li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">using KMeansClustering

# Create initialization objects
uniform_init = UniformRandomInit{Vector{Float64}}()
kmeans_pp_init = KMeansPPInit{Vector{Float64}}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L1-L30">source</a></section></article><h3 id="Concrete-Implementation"><a class="docs-heading-anchor" href="#Concrete-Implementation">Concrete Implementation</a><a id="Concrete-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-Implementation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.KMeansPPInit" href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansClustering.Init.KMeansPPInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KMeansPPInit{V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}} &lt;: ClusterInit{V}</code></pre><p>A concrete implementation of <code>ClusterInit</code> representing the k-means++ initialization strategy for clustering algorithms.</p><p>This struct implements the k-means++ initialization method, which selects initial cluster centers with a probability proportional to their squared distance from the closest center already chosen.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
kmeans_pp_init = KMeansPPInit{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L182-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.KMeansPPInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Init.KMeansPPInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.KMeansPPInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::KMeansPPInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Perform K-means++ initialization to select initial cluster centers.</p><p>This method implements the call operator for <code>KMeansPPInit</code>, allowing instances to be used as functions to generate initial cluster centers using the K-means++ algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples.</li><li><code>k::Int64</code>: Number of cluster centers to initialize.</li><li><code>normSqr::NormSqr{V}</code>: Norm function used to calculate distances between points.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{V}</code>: A vector of <code>k</code> initialized cluster centers.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">kmeans_pp = KMeansPPInit{Vector{Float64}}()
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
centers = kmeans_pp(samples, k, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L203-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.UniformRandomInit" href="#KMeansClustering.Init.UniformRandomInit"><code>KMeansClustering.Init.UniformRandomInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformRandomInit{V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}} &lt;: ClusterInit{V}</code></pre><p>A concrete implementation of <code>ClusterInit</code> representing uniform random initialization for clustering algorithms.</p><p>This struct implements the uniform random initialization strategy, where initial cluster centers are chosen uniformly at random from the bounding hyperrectangle of the input samples.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{AbstractArray{&lt;:NonInteger},&lt;:NonInteger}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
uniform_init = UniformRandomInit{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L102-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.UniformRandomInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Init.UniformRandomInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.UniformRandomInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::UniformRandomInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Initialize <code>k</code> cluster centers from <code>samples</code> using uniform random distribution over the bounding hyperrectangle of the samples.</p><p>This method implements the call operator for <code>UniformRandomInit</code>, allowing instances to be used as functions to generate initial cluster centers.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples.</li><li><code>k::Int64</code>: Number of cluster centers to initialize.</li><li><code>normSqr::NormSqr{V}</code>: Norm function (not used in this implementation but required for interface consistency).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{V}</code>: A vector of <code>k</code> initialized cluster centers.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">uniform_init = UniformRandomInit{Vector{Float64}}()
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
centers = uniform_init(samples, k, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L123-L153">source</a></section></article><h3 id="Abstract-Initializer"><a class="docs-heading-anchor" href="#Abstract-Initializer">Abstract Initializer</a><a id="Abstract-Initializer-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Initializer" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.ClusterInit" href="#KMeansClustering.Init.ClusterInit"><code>KMeansClustering.Init.ClusterInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusterInit{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing cluster initialization strategies for clustering algorithms.</p><p>This type is parameterized by <code>V</code>, which can be either a non-integer numeric type or  an array of non-integer numeric types.</p><p><strong>Purpose</strong></p><p>Subtypes of <code>ClusterInit</code> are expected to implement specific initialization strategies  for clustering algorithms, such as k-means++ initialization, random initialization,  or other custom methods.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A concrete subtype might be implemented as:
struct MyRandomInit{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: ClusterInit{V} end</code></pre><p>See also <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Init.ClusterInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Init.ClusterInit-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Init.ClusterInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::ClusterInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Initialize <code>k</code> cluster centers from <code>samples</code> using the strategy defined by <code>c</code> and the norm <code>normSqr</code>.</p><p>This is an abstract method that should be implemented by concrete subtypes of <code>ClusterInit</code>. If called on the abstract type, it raises an error.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples.</li><li><code>k::Int64</code>: Number of cluster centers to initialize.</li><li><code>normSqr::NormSqr{V}</code>: Norm function to be used in the initialization process.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{V}</code>: A vector of <code>k</code> initialized cluster centers.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>ClusterInit</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Implementing for a concrete subtype:
function (c::MyCustomInit{V})(samples::AbstractVector{V}, k::Int64, normSqr::NormSqr{V})::Vector{V} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}
    # Custom initialization logic here
    return initialize_centers(samples, k, normSqr)
end</code></pre><p>See also <a href="#KMeansClustering.Init.ClusterInit"><code>ClusterInit</code></a> <a href="#KMeansClustering.Init.UniformRandomInit"><code>UniformRandomInit</code></a>, <a href="#KMeansClustering.Init.KMeansPPInit"><code>KMeansPPInit</code></a> end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/init.jl#L63-L97">source</a></section></article><h2 id="Norm"><a class="docs-heading-anchor" href="#Norm">Norm</a><a id="Norm-1"></a><a class="docs-heading-anchor-permalink" href="#Norm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm" href="#KMeansClustering.Norm"><code>KMeansClustering.Norm</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">KMeansClustering.Norm</code></pre><p>This module defines abstract and concrete types for calculating norms, particularly squared norms, which are essential in many clustering and distance-based algorithms.</p><p><strong>Types</strong></p><ul><li><code>NormSqr{V}</code>: Abstract type for squared norm calculations</li><li><code>EuclideanNormSqr{V}</code>: Concrete type for squared Euclidean norm</li></ul><p><strong>Functions</strong></p><ul><li>Call operators for <code>NormSqr</code> and <code>EuclideanNormSqr</code> to perform norm calculations</li></ul><p><strong>Exports</strong></p><ul><li><code>NormSqr</code></li><li><code>EuclideanNormSqr</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/norm.jl#L1-L17">source</a></section></article><h3 id="Concrete-Implementation-2"><a class="docs-heading-anchor" href="#Concrete-Implementation-2">Concrete Implementation</a><a class="docs-heading-anchor-permalink" href="#Concrete-Implementation-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.EuclideanNormSqr" href="#KMeansClustering.Norm.EuclideanNormSqr"><code>KMeansClustering.Norm.EuclideanNormSqr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanNormSqr{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: NormSqr{V}</code></pre><p>A concrete implementation of <code>NormSqr</code> representing the squared Euclidean norm.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input for which this norm is defined.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance
euclidean_norm_sqr = EuclideanNormSqr{Vector{Float64}}()</code></pre><p>See also: <a href="#KMeansClustering.Norm.NormSqr"><code>NormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/norm.jl#L71-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.EuclideanNormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Norm.EuclideanNormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Norm.EuclideanNormSqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::EuclideanNormSqr{V})(x::V)::T where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Compute the squared Euclidean norm of <code>x</code>.</p><p>This method implements the call operator for <code>EuclideanNormSqr</code>, allowing instances to be used as functions to calculate squared Euclidean norms.</p><p><strong>Returns</strong></p><ul><li><code>T</code>: The computed squared Euclidean norm, which is a non-integer numeric type.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements and the result.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input, either a scalar or an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">euclidean_norm_sqr = EuclideanNormSqr{Vector{Float64}}()
v = [3.0, 4.0]
result = euclidean_norm_sqr(v)  # Returns 25.0</code></pre><p>See also: <a href="#KMeansClustering.Norm.NormSqr"><code>NormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/norm.jl#L88-L111">source</a></section></article><h3 id="Abstract-Norm"><a class="docs-heading-anchor" href="#Abstract-Norm">Abstract Norm</a><a id="Abstract-Norm-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Norm" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.NormSqr" href="#KMeansClustering.Norm.NormSqr"><code>KMeansClustering.Norm.NormSqr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormSqr{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing squared norms.</p><p>The type parameter <code>V</code> can be either a non-integer numeric type or an array of non-integer numeric types. This allows for representation of squared norms of scalars, vectors, or matrices with non-integer elements.</p><p><strong>Examples</strong></p><p>```julia</p><p><strong>Concrete subtypes might be implemented as:</strong></p><p><strong>struct MyNormSqr{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: NormSqr{V}</strong></p><p><strong>myParameter::Any</strong></p><p><strong>end</strong></p><p>See also: <a href="#KMeansClustering.Norm.EuclideanNormSqr"><code>EuclideanNormSqr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/norm.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Norm.NormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Norm.NormSqr-Union{Tuple{V}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Norm.NormSqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::NormSqr{V})(x::V)::T where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Compute the squared norm of <code>x</code> using the norm represented by <code>c</code>.</p><p><strong>Returns</strong></p><ul><li><code>T</code>: The computed squared norm, which is a non-integer numeric type.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements and the result.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input, either a scalar or an array.</li></ul><p>This is an abstract method that should be implemented by concrete subtypes of <code>NormSqr</code>. If called on the abstract type, it raises an error.</p><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>NormSqr</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">function (c::MyNormSqr{V})(x::V)::T where V&lt;:AbstractVector{&lt;:NonInteger}
    return sum(abs, x)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/norm.jl#L41-L66">source</a></section></article><h2 id="Centroid"><a class="docs-heading-anchor" href="#Centroid">Centroid</a><a id="Centroid-1"></a><a class="docs-heading-anchor-permalink" href="#Centroid" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid" href="#KMeansClustering.Centroid"><code>KMeansClustering.Centroid</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">KMeansClustering.Centroid</code></pre><p>This module provides abstract and concrete types for centroid calculation.</p><p><strong>Types</strong></p><ul><li><code>CentroidCalculator{V}</code>: Abstract type for centroid calculators.</li><li><code>EuclideanMeanCentroid{V}</code>: Concrete type for Euclidean mean centroid calculation.</li></ul><p><strong>Functions</strong></p><ul><li>Call operators for <code>CentroidCalculator</code> and <code>EuclideanMeanCentroid</code> to perform centroid calculations</li></ul><p><strong>Exports</strong></p><ul><li><code>CentroidCalculator</code></li><li><code>EuclideanMeanCentroid</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/centroid.jl#L1-L16">source</a></section></article><h3 id="Concrete-Implementation-3"><a class="docs-heading-anchor" href="#Concrete-Implementation-3">Concrete Implementation</a><a class="docs-heading-anchor-permalink" href="#Concrete-Implementation-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.EuclideanMeanCentroid" href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>KMeansClustering.Centroid.EuclideanMeanCentroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanMeanCentroid{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: CentroidCalculator{V}</code></pre><p>A concrete implementation of <code>CentroidCalculator</code> that calculates the centroid of a cluster  using the Euclidean mean (arithmetic average) of the sample points.</p><p>This centroid calculator is suitable for use with Euclidean distance-based clustering algorithms.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input samples and calculated centroids. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
euclidean_mean = EuclideanMeanCentroid{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/centroid.jl#L82-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.EuclideanMeanCentroid-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Centroid.EuclideanMeanCentroid-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Centroid.EuclideanMeanCentroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::EuclideanMeanCentroid{V})(samples::AbstractVector{V}, normSqr::NormSqr{V})::V where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Calculate the centroid of a cluster using the standard Euclidean mean (arithmetic average) of the sample points.</p><p>This method implements the call operator for <code>EuclideanMeanCentroid</code>, allowing instances to be used as functions to compute cluster centroids.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: A vector of data points in the cluster.</li><li><code>normSqr::NormSqr{V}</code>: The squared norm function (not used in this implementation but required for interface consistency).</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The calculated centroid of the cluster, which is the arithmetic mean of all points.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and the returned centroid.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">euclidean_mean = EuclideanMeanCentroid{Vector{Float64}}()
samples = [rand(3) for _ in 1:10]  # 10 3D points
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
centroid = euclidean_mean(samples, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a>, <a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>EuclideanMeanCentroid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/centroid.jl#L103-L131">source</a></section></article><h3 id="Abstract-Centroid"><a class="docs-heading-anchor" href="#Abstract-Centroid">Abstract Centroid</a><a id="Abstract-Centroid-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Centroid" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.CentroidCalculator" href="#KMeansClustering.Centroid.CentroidCalculator"><code>KMeansClustering.Centroid.CentroidCalculator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CentroidCalculator{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing methods for calculating centroids in clustering algorithms.</p><p>This type is parameterized by <code>V</code>, which can be either a non-integer numeric type or  an array of non-integer numeric types, representing the type of data points for which  centroids are being calculated.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of the data points. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Purpose</strong></p><p>Subtypes of <code>CentroidCalculator</code> can be used to implement different ways of calculating the centroid for k-Means.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A concrete subtype might be implemented as:
struct CustomCentroid{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: CentroidCalculator{V} end</code></pre><p>See also <a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>EuclideanMeanCentroid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/centroid.jl#L23-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.Centroid.CentroidCalculator-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.Centroid.CentroidCalculator-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.Centroid.CentroidCalculator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::CentroidCalculator{V})(samples::AbstractVector{V}, normSqr::NormSqr{V})::V where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}</code></pre><p>Calculate the center of a cluster from the given <code>samples</code> using the provided <code>normSqr</code>.</p><p>This is an abstract method that should be implemented by concrete subtypes of <code>CentroidCalculator</code>. If called on the abstract type, it raises an error.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: A vector of data points in the cluster.</li><li><code>normSqr::NormSqr{V}</code>: The squared norm function used for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>V</code>: The calculated center of the cluster.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and the returned center.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>CentroidCalculator</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">function (c::CustomCentroid{V})(samples::AbstractVector{V}, normSqr::NormSqr{V})::V where {T&lt;:NonInteger,N,V&lt;:Union{T, AbstractArray{T,N}}}
    return samples[1]
end</code></pre><p>See also <a href="#KMeansClustering.Centroid.CentroidCalculator"><code>CentroidCalculator</code></a>, <a href="#KMeansClustering.Centroid.EuclideanMeanCentroid"><code>EuclideanMeanCentroid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/centroid.jl#L47-L77">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms" href="#KMeansClustering.KMeansAlgorithms"><code>KMeansClustering.KMeansAlgorithms</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">KMeansAlgorithms</code></pre><p>A module containing implementations of K-means clustering algorithms.</p><p>This module provides abstract and concrete types for K-means clustering algorithms, along with utility functions for cluster assignment and center calculations.</p><p><strong>Types</strong></p><ul><li><code>KMeansAlgorithm</code>: Abstract type for K-means algorithms. Subtype to write your own implementation</li><li><code>Lloyd</code>:Implementation of Lloyd&#39;s K-means algorithm</li><li><code>BkMeans</code>: Implementation of the breathing K-means algorithm variant</li></ul><p><strong>Functions</strong></p><ul><li>Call operators for <code>KMeansAlgorithm</code>, <code>Lloyd</code> and <code>KMeansPPInit</code> to perform clustering</li></ul><p><strong>Exports</strong></p><ul><li><a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a></li><li><a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using KMeansAlgorithms

# Create a Lloyd&#39;s algorithm instance
lloyd = Lloyd{Vector{Float64}}()

# Run clustering
results = lloyd(samples, k, init, max_iter, tol, centroid, norm_sqr)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L1-L33">source</a></section></article><h3 id="Concrete-Implementation-4"><a class="docs-heading-anchor" href="#Concrete-Implementation-4">Concrete Implementation</a><a class="docs-heading-anchor-permalink" href="#Concrete-Implementation-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.BkMeans" href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>KMeansClustering.KMeansAlgorithms.BkMeans</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BkMeans{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: KMeansAlgorithm{V}</code></pre><p>A concrete implementation of <code>KMeansAlgorithm</code> representing the BkMeans clustering algorithm.</p><p><a href="https://arxiv.org/abs/2006.15666">BkMeans</a> is a variant of the K-means algorithm that aims to improve clustering quality by iteratively refining the solution through a process of &quot;breathing&quot; (adding and removing centers).</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Fields</strong></p><ul><li><code>m::Int64</code>: The number of centers to add and remove in each iteration. Default is 5.</li><li><code>eps::Float64</code>: A small value used in the center perturbation step. Default is 0.001.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">BkMeans{V}(m::Int64 = 5, eps::Float64 = 0.001) where V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code></pre><p>Constructs a BkMeans instance with the specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int64</code>: The number of centers to add and remove in each iteration. Must be non-negative.</li><li><code>eps::Float64</code>: A small value used in the center perturbation step. Must be non-negative.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either <code>m</code> or <code>eps</code> is negative.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data with default parameters
bkmeans = BkMeans{Vector{Float64}}()

# Create an instance with custom parameters
bkmeans_custom = BkMeans{Vector{Float64}}(10, 0.0005)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L229-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.BkMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.BkMeans-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.BkMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(a::BkMeans{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Execute the BkMeans clustering algorithm on the given samples.</p><p>This method implements the call operator for <code>BkMeans</code>, allowing instances to be used as functions to perform K-means clustering using the BkMeans algorithm variant. BkMeans aims to improve clustering quality by iteratively refining the solution through a process of &quot;breathing&quot; (adding and removing centers).</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples to be clustered.</li><li><code>k::Int64</code>: Number of clusters to form.</li><li><code>init::ClusterInit{V}</code>: Initialization method for cluster centers.</li><li><code>max_iter::Int64</code>: Maximum number of iterations for the algorithm.</li><li><code>tol::Float64</code>: Convergence tolerance.</li><li><code>centroid::CentroidCalculator{V}</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">bkmeans = BkMeans{Vector{Float64}}(5, 0.001)
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
init = KMeansPPInit{Vector{Float64}}()
max_iter = 100
tol = 1e-4
centroid = EuclideanMeanCentroid{Vector{Float64}}()
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
results = bkmeans(samples, k, init, max_iter, tol, centroid, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L277-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.Lloyd" href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>KMeansClustering.KMeansAlgorithms.Lloyd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lloyd{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}} &lt;: KMeansAlgorithm{V}</code></pre><p>A concrete implementation of <code>KMeansAlgorithm</code> representing Lloyd&#39;s algorithm for K-means clustering.</p><p>Lloyd&#39;s algorithm, also known as the standard K-means algorithm, iteratively reassigns points  to the nearest cluster center and recalculates cluster centers until convergence or a maximum  number of iterations is reached.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of input samples and cluster centers. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an instance for vector data
lloyd_kmeans = Lloyd{Vector{Float64}}()</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L111-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.Lloyd-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.Lloyd-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.Lloyd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(a::Lloyd{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Execute Lloyd&#39;s K-means clustering algorithm on the given samples.</p><p>This method implements the call operator for <code>Lloyd</code>, allowing instances to be used as functions to perform K-means clustering using Lloyd&#39;s algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples to be clustered.</li><li><code>k::Int64</code>: Number of clusters to form.</li><li><code>init::ClusterInit{V}</code>: Initialization method for cluster centers.</li><li><code>max_iter::Int64</code>: Maximum number of iterations for the algorithm.</li><li><code>tol::Float64</code>: Convergence tolerance.</li><li><code>centroid::CentroidCalculator{V}</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>k ≤ 0</code> or if <code>k</code> is greater than the number of samples.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lloyd = Lloyd{Vector{Float64}}()
samples = [rand(3) for _ in 1:100]  # 100 3D points
k = 5
init = KMeansPPInit{Vector{Float64}}()
max_iter = 100
tol = 1e-4
centroid = EuclideanMeanCentroid{Vector{Float64}}()
norm_sqr = EuclideanNormSqr{Vector{Float64}}()
results = lloyd(samples, k, init, max_iter, tol, centroid, norm_sqr)</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L133-L174">source</a></section></article><h3 id="Abstract-KMeansAlgorithms"><a class="docs-heading-anchor" href="#Abstract-KMeansAlgorithms">Abstract KMeansAlgorithms</a><a id="Abstract-KMeansAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-KMeansAlgorithms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.KMeansAlgorithm" href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansClustering.KMeansAlgorithms.KMeansAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KMeansAlgorithm{V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}}</code></pre><p>An abstract type representing K-means clustering algorithms.</p><p>This type is parameterized by <code>V</code>, which can be either a non-integer numeric type or  an array of non-integer numeric types, representing the type of data points being clustered.</p><p><strong>Type Parameters</strong></p><ul><li><code>V&lt;:Union{&lt;:NonInteger,AbstractArray{&lt;:NonInteger}}</code>: The type of the data points. Can be either a non-integer numeric type or an array of non-integer numeric types.</li></ul><p><strong>Purpose</strong></p><p>Subtypes of <code>KMeansAlgorithm</code> are expected to implement specific variants of the  K-means clustering algorithm, such as Lloyd&#39;s algorithm, mini-batch K-means, or  other custom methods.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A concrete subtype might be implemented as:
struct MyAlgorithm{V&lt;:AbstractVector{&lt;:NonInteger}} &lt;: KMeansAlgorithm{V} end</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L43-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KMeansClustering.KMeansAlgorithms.KMeansAlgorithm-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}" href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm-Union{Tuple{V}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{V}, Int64, ClusterInit{V}, Int64, Float64, CentroidCalculator{V}, NormSqr{V}}} where {T&lt;:Real, N, V&lt;:Union{AbstractArray{T, N}, T}}"><code>KMeansClustering.KMeansAlgorithms.KMeansAlgorithm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(a::KMeansAlgorithm{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}</code></pre><p>Execute a K-means clustering algorithm on the given samples.</p><p>This is an abstract method that should be implemented by concrete subtypes of <code>KMeansAlgorithm</code>. If called on the abstract type, it raises an error.</p><p><strong>Arguments</strong></p><ul><li><code>samples::AbstractVector{V}</code>: Input data samples to be clustered.</li><li><code>k::Int64</code>: Number of clusters to form.</li><li><code>init::ClusterInit{V}</code>: Initialization method for cluster centers.</li><li><code>max_iter::Int64</code>: Maximum number of iterations for the algorithm.</li><li><code>tol::Float64</code>: Convergence tolerance.</li><li><code>centroid::CentroidCalculator{V}</code>: Method to calculate cluster centroids.</li><li><code>normSqr::NormSqr{V}</code>: Squared norm function for distance calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{Pair{V, AbstractVector{V}}}</code>: A vector of pairs, where each pair consists of a cluster center and a vector of samples assigned to that center.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:NonInteger</code>: The numeric type of the elements.</li><li><code>N</code>: The number of dimensions if <code>V</code> is an array type.</li><li><code>V&lt;:Union{T,AbstractArray{T,N}}</code>: The type of the input samples and cluster centers.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the method is not implemented for the specific subtype of <code>KMeansAlgorithm</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Implementing for a concrete subtype:
function (a::MyCustomKMeans{V})(samples::AbstractVector{V}, k::Int64, init::ClusterInit{V}, max_iter::Int64, tol::Float64, centroid::CentroidCalculator{V}, normSqr::NormSqr{V})::AbstractVector{Pair{V, AbstractVector{V}}} where {T&lt;:NonInteger,N,V&lt;:Union{T,AbstractArray{T,N}}}
    # Custom K-means algorithm implementation
    return cluster_results
end</code></pre><p>See also <a href="#KMeansClustering.KMeansAlgorithms.KMeansAlgorithm"><code>KMeansAlgorithm</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.Lloyd"><code>Lloyd</code></a>, <a href="#KMeansClustering.KMeansAlgorithms.BkMeans"><code>BkMeans</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idil-tub/KMeansClustering.jl/blob/05361633e8d14ddda2475720a5e987f2701b4448/src/kmeans_algorithms.jl#L69-L106">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">« Installation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 11 July 2024 16:20">Thursday 11 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
